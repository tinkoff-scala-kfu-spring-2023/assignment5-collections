# Траверс по дереву
Написать свое бинарное дерево, у которого будет:
* добавление/удаление элементов (фул иммутабельность)
* функции трансформации map, foldLeft
* bfs, dfs поиски

# Коллекции
Реализуйте все функции в папке collections

Покройте функции тестами

# Проветривание

**Все имена вымышленные, совпадения случайны**

В Казани офис компании Тинькофф имеет очень продолговатую форму, так что программисты могут сидеть только в одном ряду.
К сожалению, в офисе недостаточно кондиционеров, а сидят в нем только скалисты в количестве **N** штук. Из-за жалоб на духоту,
HR менеджер по имени Ильзида приняла решение купить каждому скалисту вентилятор, но выяснилось, что в некоторых 
случаях одного вентилятора недостаточно, и нужно выдавать несколько. Тогда Ильзида решила определить степень духоты
каждого скалиста и выдать количество вентиляторов, зависящее от самого душного скалиста в окрестности размера **К**.
Для этого ей необходима функция, получающая на вход список степеней духоты (ограничимся Int) и длину окрестности и находящая уровень духоты самого душного скалиста для каждой последовательности скалистов размера **К**.

* Помогите Ильзиде найти два решения:
   1) Только при помощи методов, которые предоставляет `scala.collection.immutable.List[A]`.
   2) За O(N) по времени и O(k) по памяти - оказалось, что офис в Калтане слишком длинный, а смету на закупку вентиляторов надо составить как можно быстрее. Запрещено использовать мутабельные структуры. Подумайте, какие практики из прошлых домашних заданий здесь можно применить.

## Пример

| аргументы функции                 | результат функции |
|-----------------------------------|-------------------|
| `degrees = List(1, 2, 3, 4), k = 2` | `List(2, 3, 4)`    |

Для нашего офиса существует 3 подлиста размером 2: [[1, 2], [2, 3], [3, 4]]. Возьмем максимальных душнил в каждом из этих листов и получим ответ: [2, 3, 4]

## Замечания
* 1<=K<=N
* N >=0. Возвращать пустой лист, если N=0
* Написать все нужные тесты
* Объяснить, какая сложность по памяти и времени у 1-го решения, и как были достигнуты необходимые лимиты по времени и памяти во втором - **отдельным  файлом complexity.md в корне папки проекта**
